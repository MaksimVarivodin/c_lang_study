# 1.5.4. Подсчет слов
Четвертая из нашей серии полезных программ подсчитывает строки, слова и символы, причем под словом здесь имеется в виду любая строка символов, не содержащая в себе пробелов, табуляций и символов новой строки. Эта программа является упрощенной версией программы `wc` системы UNIX.

```c
#include <stdio.h>
#define IN 1 /* внутри слова */
#define OUT 0 /* вне слова */

/* подсчет строк, слов и символов */
main (){
    int c, nl, nw, nc, state;
    state = OUT;
    nl = nw = nc = 0;
    while ((c = getchar()) != EOF) {
        ++nc;
        if (c == '\n' )++nl;
        if (c == " " || c == '\n' || c == '\t')
            state = OUT;
        else if (state == OUT) {
            state = IN;
            ++nw;
        }
    }
    printf ("%d %d %d\n", nl, nw, nc);
}
```

Каждый раз, встречая первый символ слова, программа изменяет значение счетчика слов на 1. Переменная `state` фиксирует текущее состояние — находимся мы внутри или вне слова. Вначале ей присваивается значение OUT, что соответствует состоянию "вне слова". Мы предпочитаем пользоваться именованными константами IN и OUT, а не собственно значениями 1 и 0, чтобы сделать программу более понятной. В такой маленькой программе этот прием мало что дает, но в большой программе увеличение ее ясности окупает незначительные дополнительные усилия, потраченные на то, чтобы писать программу в таком стиле с самого начала. Вы обнаружите, что большие изменения гораздо легче вносить в те программы, в которых магические числа встречаются только в виде именованных констант.

Строка `nl = nw = nc = 0;` устанавливает все три переменные в нуль. Такая запись не является какой-то особой конструкцией и допустима потому, что присваивание есть выражение со своим собственным значением, а операции присваивания выполняются справа налево. Указанная строка эквивалентна `nl = (nw = (nc = 0));`.

Оператор `||` означает ИЛИ, так что строка `if (c == ' ' || c == '\n' || c == '\t')`читается как "если `c` есть пробел, или `c` есть новая строка, или `c` есть табуляция". (Напомним, что видимая эскейп-последовательность `\t` обозначает символ табуляции.) Существует также оператор `&&`, означающий И. Его приоритет выше, чем приоритет `||`. Выражения, связанные операторами `&&` или `||`, вычисляются слева направо; при этом гарантируется, что вычисления сразу прервутся, как только будет установлена истинность или ложность условия. Если `c` есть пробел, то дальше проверять, является значение `c` символьной строкой или же табуляцией, не нужно. В этом частном случае данный способ вычислений не столь важен, но он имеет значение в более сложных ситуациях, которые мы вскоре рассмотрим.

В примере также встречается слово `else`, которое указывает на альтернативные действия, выполняемые в случае, когда условие, указанное в `if`, не является истинным. В общем виде условная инструкция записывается так: `if (выражение) инструкция1 else инструкция2`. В конструкции `if-else` выполняется одна и только одна из двух инструкций. Если выражение истинно, то выполняется инструкция1, если нет, то инструкция2. Каждая из этих двух инструкций представляет собой либо одну инструкцию, либо несколько, заключенных в фигурные скобки. В нашей программе после `else` стоит инструкция `if`, управляющающая двумя такими инструкциями.