
1.5.1. Копирование файла

При наличии функций `getchar` и `putchar`, ничего больше не зная о вводе-выводе, можно написать удивительно много
полезных программ. Простейший пример — это программа, копирующая по одному символу с входного потока в выходной поток:

- чтение символа
- пока символ не является признаком конца файла
    - вывод только что прочитанного символа
    - чтение символа

Оформляя ее в виде программы на Си, получим:

```c
#include <stdio.h>

int main() {
    int c;
    c = getchar();
    while (c != EOF) {
        putchar(c);
        c = getchar();
    }
    return 0;
}
```

Оператор отношения `!=` означает "не равно".

Каждый символ, вводимый с клавиатуры или отображаемый на экране, как и любой другой символ внутри машины, кодируется
комбинацией битов. Тип `char` специально предназначен для хранения символьных данных, но для этого также годится и любой
целый тип. Мы используем `int` и делаем это из-за одной важной причины, которая требует разъяснений.

Существует проблема: как отличить конец ввода от обычных читаемых данных. Решение заключается в том, чтобы
функция `getchar` по исчерпании входного потока выдавала в качестве результата такое значение, которое нельзя было бы
спутать ни с одним реальным символом. Это значение есть `EOF` (аббревиатура от "end of file" — конец файла). Мы должны
объявить переменную `c` такого типа, чтобы ее "хватило" для представления всех возможных результатов, выдаваемых
функцией `getchar`. Нам не подходит тип `char`, так как `c` должна быть достаточно "емкой", чтобы помимо любого значения
типа `char` быть в состоянии хранить и `EOF`. Вот почему мы используем `int`, а не `char`.

`EOF` — это целая константа, определенная в `<stdio.h>`. Какое значение имеет эта константа — не важно, главное, чтобы
оно отличалось от любого из возможных значений типа `char`. Использование именованной константы с унифицированным именем
гарантирует, что программа не будет зависеть от конкретного числового значения, которое, возможно, в других Си-системах
будет иным.

Программу копирования можно написать более сжато. В Си любое присваивание, например `c = getchar()`, трактуется как
выражение со значением, равным значению левой части после присваивания. Это значит, что присваивание может встречаться
внутри более сложного выражения. Если присваивание переменной `c` расположить в проверке условия цикла `while`, то
программу копирования можно будет записать в следующем виде:

```c
#include <stdio.h>

int main() {
    int c;
    while ((c = getchar()) != EOF) {
        putchar(c);
    }
    return 0;
}
```

Цикл `while`, пересылая в `c` полученное от `getchar` значение, сразу же проверяет: не является ли оно "концом файла".
Если это не так, выполняется тело цикла `while` и печатается символ. По окончании ввода завершается работа
цикла `while`, а тем самым и `main`.

В данной версии ввод "централизован" — в программе имеется только одно обращение к `getchar`. В результате она более
компактна и легче воспринимается при чтении. Вам часто придется сталкиваться с такой формой записи, где присваивание
делается вместе с проверкой. (Чрезмерное увлечение ею, однако, может запутать программу, поэтому мы постараемся
пользоваться указанной формой разумно.)

Скобки внутри условия, вокруг присваивания, необходимы. Приоритет `!=` выше, чем приоритет `=`, из-за чего при
отсутствии скобок проверка `!=` будет выполняться до операции присваивания `=`. Таким образом,
запись `c = getchar() != EOF` эквивалентна записи `c = (getchar() != EOF)`. Это совсем не то, что нам нужно:
переменной `c` будет присваиваться `0` или `1` в зависимости от того, встретит или не встретит `getchar` признак конца
файла. (Более подробно об этом см. в главе 2.)

Упражнение 1.6. Убедитесь в том, что выражение `getchar() != EOF` получает значение `0` или `1`.

Упражнение 1.7. Напишите программу, печатающую значение `EOF`.